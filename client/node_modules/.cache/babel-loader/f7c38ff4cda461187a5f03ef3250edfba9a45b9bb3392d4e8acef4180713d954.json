{"ast":null,"code":"/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nvar fs = require('fs');\nvar path = require('path');\nvar os = require('os');\nfunction log(message /*: string */) {\n  console.log(\"[dotenv][DEBUG] \".concat(message));\n}\nvar NEWLINE = '\\n';\nvar RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/;\nvar RE_NEWLINES = /\\\\n/g;\nvar NEWLINES_MATCH = /\\r\\n|\\n|\\r/;\n\n// Parses src into an Object\nfunction parse(src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */{\n  var debug = Boolean(options && options.debug);\n  var obj = {};\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    var keyValueArr = line.match(RE_INI_KEY_VAL);\n    // matched?\n    if (keyValueArr != null) {\n      var key = keyValueArr[1];\n      // default undefined or missing values to empty string\n      var val = keyValueArr[2] || '';\n      var end = val.length - 1;\n      var isDoubleQuoted = val[0] === '\"' && val[end] === '\"';\n      var isSingleQuoted = val[0] === \"'\" && val[end] === \"'\";\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end);\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE);\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim();\n      }\n      obj[key] = val;\n    } else if (debug) {\n      log(\"did not match key and value when parsing line \".concat(idx + 1, \": \").concat(line));\n    }\n  });\n  return obj;\n}\nfunction resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\n\n// Populates process.env from .env file\nfunction config(options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */{\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  var encoding /*: string */ = 'utf8';\n  var debug = false;\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = resolveHome(options.path);\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n    if (options.debug != null) {\n      debug = true;\n    }\n  }\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    var parsed = parse(fs.readFileSync(dotenvPath, {\n      encoding: encoding\n    }), {\n      debug: debug\n    });\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key];\n      } else if (debug) {\n        log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and will not be overwritten\"));\n      }\n    });\n    return {\n      parsed: parsed\n    };\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n}\nmodule.exports.config = config;\nmodule.exports.parse = parse;","map":{"version":3,"names":["fs","require","path","os","log","message","console","NEWLINE","RE_INI_KEY_VAL","RE_NEWLINES","NEWLINES_MATCH","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","val","end","length","isDoubleQuoted","isSingleQuoted","substring","replace","trim","resolveHome","envPath","join","homedir","slice","config","dotenvPath","resolve","process","cwd","encoding","parsed","readFileSync","Object","keys","prototype","hasOwnProperty","call","env","e","error","module","exports"],"sources":["/Users/tazh/Desktop/Study/Record-Store/client/node_modules/dotenv/lib/main.js"],"sourcesContent":["/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\r\\n|\\n|\\r/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\nfunction resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}